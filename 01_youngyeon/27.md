# 27. 보안

[차례및 범례](https://www.notion.so/70c7bb58613441dc9221e892a8eca912)

# 태그

---

#보안 #스프링시큐리티 #시큐리티 #security

# 질문

---

로그인 하는 방법은?

스프링 시큐리티 란?

권한설정도 가능한가?

메뉴별 권한설정도 가능한가?

로그인 종류별(session,cookie,jwt등)로 지원하나?

# 결론

---

스프링-시큐리티를 디테일하게 공부하기는 힘들다. 해당 주제를 가지고 새로운 프로젝트를 열어야 한다. 이유는 작은 주제가 아니고 공부할 내용들이 너무나 많다. 

여기서는 간단하게 로그인 처리를 하는 프레임워크라고 생각하면 될듯 싶다. 

# 설명

---

스프링 시큐리티는 웹 애플리케이션의 모든 HTTP 앤드포인트들에 대한 기초적인 인증을 기본적인 보안을 처리한다. 

보안: 인증과 권한(인가)

그렇다면 만약...스프링 시큐리티를 사용하지 않는다면 무슨일이?

자체적으로 세션을 체크하고, redirect등을 해야 한다. 

## 스프링 시큐리티의 특징

---

- 보안과 관련해서 체계적으로 많은 옵션들로 이를 지원
- filter 기반으로 동작
- spring mvc 와 분리되어 관리 및 동작
- security 3.2부터는 xml로 설정하지 않고도 자바 bean 설정으로 간단하게 설정 가능

## 로그인 방식

---

- 세션/쿠키 인증: [https://tansfil.tistory.com/58?category=255594](https://tansfil.tistory.com/58?category=255594)
- Access Token + Refresh Token: [https://tansfil.tistory.com/59?category=255594](https://tansfil.tistory.com/59?category=255594)
- SNS 로그인: [https://tansfil.tistory.com/60?category=255594](https://tansfil.tistory.com/60?category=255594)

## 보안관련 용어 정리

- 접근주체: 보호된 대상에 접근하는 유저
- 인증: 현재 유저가 누구인지 확인
    - 애플리케이션의 작업을 수행할 수 있는 주체임을 증명
- 인가: 현재 유저가 어떤 서비스, 페이지에 접근할 수 있는 권한이 있는지 검사
- 권한: 인증된 주체가 애플리케이션의 동작을 수행할 수 있도록 허락되었는지를 결정
    - 권한 승인이 필요한 부분으로 접근하려면 인증 과정을 통해 주체가 증명 되어야만 한다.
    - 권한 부여에도 두가지 영역이 존재하는데 웹 요청 권한, 메소드 호출 및 도메인 인스턴스에 대한 접근 권한 부여

## 인증관련 아키텍처

![27/Untitled.png](27/Untitled.png)

## 참고

---

스프링 시큐리티 구조 이해 : [https://www.slideshare.net/madvirus/ss-36809454](https://www.slideshare.net/madvirus/ss-36809454)

스프링 파혜치기: [https://sjh836.tistory.com/165](https://sjh836.tistory.com/165)

초보자가 이해하는 Spring Security: [https://postitforhooney.tistory.com/entry/SpringSecurity-초보자가-이해하는-Spring-Security-퍼옴](https://postitforhooney.tistory.com/entry/SpringSecurity-%EC%B4%88%EB%B3%B4%EC%9E%90%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Spring-Security-%ED%8D%BC%EC%98%B4)

## 설정

---

## application.yml

---

property를 이용해서 비밀번호 변경이 가능하다.

    security.user.password: 1234

## 주요어노테이션

---

@EnableGlobalMethodSecutity

@EnableSecurity

### 샘플소스

---

    @Configuration
    @EnableGlobalMethodSecurity(securedEnabled = true)
    public class MethodSecurityConfig {
       // ...
    }
    public interface BankService {
    
      @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
      public Account readAccount(Long id);
    
      @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
      public Account[] findAccounts();
    
      @Secured("ROLE_TELLER")
      public Account post(Account account, double amount);
    }
    ---
    @Configuration
    @EnableGlobalMethodSecurity(jsr250Enabled = true)
    public class MethodSecurityConfig {
       // ...
    }
    ---
    // 스프링 시큐리티 3.0부터 지원하는 표현식 기반의 문법을 사용 가능
    @Configuration
    @EnableGlobalMethodSecurity(prePostEnabled = true)
    public class MethodSecurityConfig {
       // ...
    }
    public interface BankService {
    
      @PreAuthorize("isAnonymous()")
      public Account readAccount(Long id);
    
      @PreAuthorize("isAnonymous()")
      public Account[] findAccounts();
    
      @PreAuthorize("hasAuthority('ROLE_TELLER')")
      public Account post(Account account, double amount);
    }

## EnableGlobalMethodSecurity 종류

---

- (securedEnabled ) 스프링 시큐리티의 @Secured: 스프링 기반 어노테이션
- (jsr250Enabled ) JSR-250의 @RolesAllowed: 자바표준 어노테이션
    - 동작방식이 @Secured와 동일
    - 다른 프레임워크나 API 컨텍스트에서 사용될 때에도 사용이 가능한 이점
    - 메소드 실행을 권한만이 관리하며, 다른 펙터들이 없다는 한계점
- (prePostEnabled ) 표현식 주도의 애너테이션(@PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter을 사용)

## HttpSecurity config 설정

---

    @Override
    protected void configure(HttpSecurity http) throws Exception {
    	http.httpBasic()
    		.and()
    		.authorizeRequests()
    			.antMatchers("/users/{userId}").access("@authenticationCheckHandler.checkUserId(authentication,#userId)")
    			.antMatchers("/admin/db/**").access("hasRole('ADMIN_MASTER') or hasRole('ADMIN') and hasRole('DBA')")
    			.antMatchers("/register/**").hasRole("ANONYMOUS")
    		.and()
    		.formLogin()
    			.loginPage("/login")
    			.usernameParameter("email")
    			.passwordParameter("password")
    			.successHandler(successHandler())
    			.failureHandler(failureHandler())
    			.permitAll();
    }

# 실습

---

## HttpSession, 회원가입, 로그인

---

웹에서 로그인의 가장 기본적인 방식은 HttpSession 객체를 이용해서 사용자의 정보를 보관하고, 필요한 경우 사용하거나 수정하는 방식이다.

**jsp + mybatis + httpSession 코드 인데 mybatis 부분만 jpa 연동으로 포팅 해야 함.**

session에 보관된 객체는 JSP에서 EL을 이용해서 자동으로 추적하는 방식을 사용한다. 예를 들면 ${name}은 page -> request -> session -> application의 순서대로 원하는 데이터를 검색한다.

### HttpSession

---

HttpSession은 둘 이상의 페이지의 요청 또는 웹사이트를 방문한 사용자를 식별하고 해당 사용자에 대한 정보를 저장하는 방법을 제공한다.

- 서블릿 컨테이너는 Http 클라이언트와 Http 서버 사이의 세션을 만드는데 사용한다.
- Session은 사용자의 둘 이상의 연결 또는 페이지 요청을 통해 지정된 기간 동안 유지된다.
- Session은 보통 웹사이트를 여러번 방문하는 하나의 사용자에 해당한다.
- 서버는 쿠키를 사용하거나 URL 다시쓰기 등과 같은 여러가지 방법으로 session을 유지할 수 있다.

HttpSession은 서블릿이 다음 작업을 수행하도록 허용한다.

- Session 식별자, 생성시간, 마지막 접근 시간과 같은 세션에 대한 정보를 조작하고 볼 수 있다.
- 객체를 Session에 바인딩하여 여러 사용자 연결에서 사용자 정보가 유지되도록 한다.

### 소스코드

---

    -- 회원 테이블
    CREATE TABLE tbl_user (
      user_id VARCHAR(50) NOT NULL,
      user_pw VARCHAR(100) NOT NULL,
      user_name VARCHAR(100) NOT NULL,
      user_email VARCHAR(50) NOT NULL,
      user_point INT NOT NULL DEFAULT 0,
      session_key VARCHAR(50) NOT NULL DEFAULT 'none',
      session_limit TIMESTAMP,
      user_img VARCHAR(100) NOT NULL DEFAULT 'user/default-user.png',
      user_join_date TIMESTAMP NOT NULL DEFAULT NOW(),
      user_login_date TIMESTAMP NOT NULL DEFAULT NOW(),
      user_signature VARCHAR(200) NOT NULL DEFAULT '안녕하세요 ^^',
      PRIMARY KEY (user_id)
    );

    public class UserVO {
    
        private String userId;
        private String userPw;
        private String userName;
        private String userEmail;
        private Date userJoinDate;
        private Date userLoginDate;
        private String userSignature;
        private String userImg;
        private int userPoint;
    
        // getter, setter, toString 생략 
    }

    public interface UserDAO {
        
        // 회원가입 처리
        void register(UserVO userVO) throws Exception;
    }

    @Repository
    public class UserDAOImpl implements UserDAO {
        
        private static final String NAMESPACE = "com.doubles.mvcboard.mappers.user.UserMapper";
        
        private final SqlSession sqlSession;
    
        @Inject
        public UserDAOImpl(SqlSession sqlSession) {
            this.sqlSession = sqlSession;
        }
        
        // 회원가입처리
        @Override
        public void register(UserVO userVO) throws Exception {
            sqlSession.insert(NAMESPACE + ".register", userVO);
        }
        
    }

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
    <mapper namespace="com.doubles.mvcboard.mappers.user.UserMapper">
        
        <insert id="register">
            INSERT INTO tbl_user (
                user_id
                , user_pw
                , user_name
                , user_email
            ) VALUES (
                #{userId}
                , #{userPw}
                , #{userName}
                , #{userEmail}
            )
        </insert>
        
    </mapper>

    public interface UserService {
        
        // 회원 가입 처리
        void register(UserVO userVO) throws Exception;
        
    }

    @Service
    public class UserServiceImpl implements UserService {
    
        private final UserDAO userDAO;
    
        @Inject
        public UserServiceImpl(UserDAO userDAO) {
            this.userDAO = userDAO;
        }
        
        // 회원 가입 처리
        @Override
        public void register(UserVO userVO) throws Exception {
            userDAO.register(userVO);
        }

    @Controller
    @RequestMapping("/user")
    public class UserRegisterController {
    
        private final UserService userService;
    
        @Inject
        public UserRegisterController(UserService userService) {
            this.userService = userService;
        }
    
        // 회원가입 페이지
        @RequestMapping(value = "/register", method = RequestMethod.GET)
        public String registerGET() throws Exception {
            return "/user/register";
        }
    
        // 회원가입 처리
        @RequestMapping(value = "/register", method = RequestMethod.POST)
        public String registerPOST(UserVO userVO, RedirectAttributes redirectAttributes) throws Exception {
    
            String hashedPw = BCrypt.hashpw(userVO.getUserPw(), BCrypt.gensalt());
            userVO.setUserPw(hashedPw);
            userService.register(userVO);
            redirectAttributes.addFlashAttribute("msg", "REGISTERED");
    
            return "redirect:/user/login";
        }
        
    }

jsp → 타임리프로 바꿔서 해도 상관없음. 

회원 가입 페이지

    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <!DOCTYPE html>
    <html>
    <%@ include file="../include/head.jsp" %>
    <body class="hold-transition register-page">
    <div class="register-box">
        <div class="register-logo">
            <a href="${path}/">
                <b>DoubleS</b>&nbsp MVC-BOARD
            </a>
        </div>
    
        <div class="register-box-body">
            <p class="login-box-msg">회원가입 페이지</p>
    
            <form action="${path}/user/register" method="post">
                <div class="form-group has-feedback">
                    <input type="text" name="userId" class="form-control" placeholder="아아디">
                    <span class="glyphicon glyphicon-exclamation-sign form-control-feedback"></span>
                </div>
                <div class="form-group has-feedback">
                    <input type="text" name="userName" class="form-control" placeholder="이름">
                    <span class="glyphicon glyphicon-user form-control-feedback"></span>
                </div>
                <div class="form-group has-feedback">
                    <input type="email" name="userEmail" class="form-control" placeholder="이메일">
                    <span class="glyphicon glyphicon-envelope form-control-feedback"></span>
                </div>
                <div class="form-group has-feedback">
                    <input type="password" name="userPw" class="form-control" placeholder="비밀번호">
                    <span class="glyphicon glyphicon-lock form-control-feedback"></span>
                </div>
                <div class="form-group has-feedback">
                    <input type="password" class="form-control" placeholder="비밀번호 확인">
                    <span class="glyphicon glyphicon-log-in form-control-feedback"></span>
                </div>
                <div class="row">
                    <div class="col-xs-8">
                        <div class="checkbox icheck">
                            <label>
                                <input type="checkbox"> 약관에 <a href="#">동의</a>
                            </label>
                        </div>
                    </div>
                    <div class="col-xs-4">
                        <button type="submit" class="btn btn-primary btn-block btn-flat">가입</button>
                    </div>
                </div>
            </form>
    
            <div class="social-auth-links text-center">
                <p>- 또는 -</p>
                <a href="#" class="btn btn-block btn-social btn-facebook btn-flat">
                    <i class="fa fa-facebook"></i> 페이스북으로 가입
                </a>
                <a href="#" class="btn btn-block btn-social btn-google btn-flat">
                    <i class="fa fa-google-plus"></i> 구글 계정으로 가입
                </a>
            </div>
    
            <a href="${path}/user/login" class="text-center">로그인</a>
        </div>
        <!-- /.form-box -->
    </div>
    <!-- /.register-box -->
    
    <%@ include file="../include/plugin_js.jsp" %>
    <script>
        $(function () {
            $('input').iCheck({
                checkboxClass: 'icheckbox_square-blue',
                radioClass: 'iradio_square-blue',
                increaseArea: '20%' // optional
            });
        });
    </script>
    </body>
    </html>

로그인 페이지 

    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <!DOCTYPE html>
    <html>
    <%@ include file="../include/head.jsp" %>
    <body class="hold-transition login-page">
    <div class="login-box">
        <div class="login-logo">
            <a href="${path}/">
                <b>DoubleS</b>&nbsp MVC-BOARD
            </a>
        </div>
        <!-- /.login-logo -->
        <div class="login-box-body">
            <p class="login-box-msg">로그인 페이지</p>
    
            <form action="${path}/user/loginPost" method="post">
                <div class="form-group has-feedback">
                    <input type="text" name="userId" class="form-control" placeholder="아아디">
                    <span class="glyphicon glyphicon-exclamation-sign form-control-feedback"></span>
                </div>
                <div class="form-group has-feedback">
                    <input type="password" name="userPw" class="form-control" placeholder="비밀번호">
                    <span class="glyphicon glyphicon-lock form-control-feedback"></span>
                </div>
                <div class="row">
                    <div class="col-xs-8">
                        <div class="checkbox icheck">
                            <label>
                                <input type="checkbox" name="useCookie"> 로그인유지
                            </label>
                        </div>
                    </div>
                    <!-- /.col -->
                    <div class="col-xs-4">
                        <button type="submit" class="btn btn-primary btn-block btn-flat">
                            <i class="fa fa-sign-in"></i> 로그인
                        </button>
                    </div>
                    <!-- /.col -->
                </div>
            </form>
    
            <div class="social-auth-links text-center">
                <p>- 또는 -</p>
                <a href="#" class="btn btn-block btn-social btn-facebook btn-flat">
                    <i class="fa fa-facebook"></i> 페이스북으로 로그인
                </a>
                <a href="#" class="btn btn-block btn-social btn-google btn-flat">
                    <i class="fa fa-google-plus"></i> 구글 계정으로 로그인
                </a>
            </div>
            <!-- /.social-auth-links -->
    
            <a href="#">비밀번호 찾기</a><br>
            <a href="${path}/user/register" class="text-center">회원가입</a>
    
        </div>
        <!-- /.login-box-body -->
    </div>
    <!-- /.login-box -->
    
    <%@ include file="../include/plugin_js.jsp" %>
    <script>
    
        var msg = "${msg}";
        if (msg === "REGISTERED") {
            alert("회원가입이 완료되었습니다. 로그인해주세요~");
        } else if (msg == "FAILURE") {
            alert("아이디와 비밀번호를 확인해주세요.");
        }
    
        $(function () {
            $('input').iCheck({
                checkboxClass: 'icheckbox_square-blue',
                radioClass: 'iradio_square-blue',
                increaseArea: '20%' // optional
            });
        });
    </script>
    </body>
    </html>

    public class LoginDTO {
    
        private String userId;
        private String userPw;
        private boolean useCookie;
    
        // getter, setter, toString 생략
    }

    @Override
    public UserVO login(LoginDTO loginDTO) throws Exception {
        return sqlSession.selectOne(NAMESPACE + ".login", loginDTO);
    }

    <select id="login" resultMap="userVOResultMap">
        SELECT
          *
        FROM tbl_user
        WHERE user_id = #{userId}
    </select>

    @Override
    public UserVO login(LoginDTO loginDTO) throws Exception {
        return userDAO.login(loginDTO);
    }

    @Controller
    @RequestMapping("/user")
    public class UserLoginController {
    
        private final UserService userService;
    
        @Inject
        public UserLoginController(UserService userService) {
            this.userService = userService;
        }
    
        // 로그인 페이지
        @RequestMapping(value = "/login", method = RequestMethod.GET)
        public String loginGET(@ModelAttribute("loginDTO") LoginDTO loginDTO) {
            return "/user/login";
        }
    
        // 로그인 처리
        @RequestMapping(value = "/loginPost", method = RequestMethod.POST)
        public void loginPOST(LoginDTO loginDTO, HttpSession httpSession, Model model) throws Exception {
    
            UserVO userVO = userService.login(loginDTO);
    
            if (userVO == null || !BCrypt.checkpw(loginDTO.getUserPw(), userVO.getUserPw())) {
                return;
            }
    
            model.addAttribute("user", userVO);
            
        }
        
    }

로그인 인터셉터 

    public class LoginInterceptor extends HandlerInterceptorAdapter {
    
        private static final String LOGIN = "login";
        private static final Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);
    
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    
            HttpSession httpSession = request.getSession();
            ModelMap modelMap = modelAndView.getModelMap();
            Object userVO =  modelMap.get("user");
    
            if (userVO != null) {
                logger.info("new login success");
                httpSession.setAttribute(LOGIN, userVO);
                response.sendRedirect("/");
            }
    
        }
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    
            HttpSession httpSession = request.getSession();
            // 기존의 로그인 정보 제거
            if (httpSession.getAttribute(LOGIN) != null) {
                logger.info("clear login data before");
                httpSession.removeAttribute(LOGIN);
            }
    
            return true;
        }
    }

권한인터셉터

    public class AuthInterceptor extends HandlerInterceptorAdapter {
    
        private static final Logger logger = LoggerFactory.getLogger(AuthInterceptor.class);
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    
            HttpSession httpSession = request.getSession();
    
            if (httpSession.getAttribute("login") == null) {
                logger.info("current user is not logged");
                response.sendRedirect("/user/login");
                return false;
            }
    
            return true;
        }
    }

자동페이지 이동처리

    public class AuthInterceptor extends HandlerInterceptorAdapter {
    
        private static final Logger logger = LoggerFactory.getLogger(AuthInterceptor.class);
        
        // 페이지 요청 정보 저장
        private void saveDestination(HttpServletRequest request) {
            String uri = request.getRequestURI();
            String query = request.getQueryString();
            if (query == null || query.equals("null")) {
                query = "";
            } else {
                query = "?" + query;
            }
    
            if (request.getMethod().equals("GET")) {
                logger.info("destination : " + (uri + query));
                request.getSession().setAttribute("destination", uri + query);
            }
        }
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    
            HttpSession httpSession = request.getSession();
    
            if (httpSession.getAttribute("login") == null) {
                logger.info("current user is not logged");
                saveDestination(request);
                response.sendRedirect("/user/login");
                return false;
            }
    
            return true;
        }
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    
        HttpSession httpSession = request.getSession();
        ModelMap modelMap = modelAndView.getModelMap();
        Object userVO =  modelMap.get("user");
    
        if (userVO != null) {
            logger.info("new login success");
            httpSession.setAttribute(LOGIN, userVO);
            //response.sendRedirect("/");
            Object destination = httpSession.getAttribute("destination");
            response.sendRedirect(destination != null ? (String) destination : "/");
        }
    }

## Basic 로그인

---

스프링 부트에서는 사용자의 요청에 따라 어플리케이션 개발자가 인증 절차를 상황에 맞게 설정할 수 있습니다.

### 의존성 관리

---

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

### html 파일

---

    index.html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <h1>This is Security Test</h1>
        <a href="/my">my</a>
        <a href="/hello">hello</a>
    </body>
    </html>
    
    
    my.html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <h1>my</h1>
    </body>
    </html>
    
    hello.html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <h1>Hello</h1>
    </body>
    </html>

### 소스코드

---

    @SpringBootApplication
    public class SpringSecurityApplication {
    
        public static void main(String[] args) {
            SpringApplication.run(SpringSecurityApplication.class, args);
        }
    }

    @Controller
    public class SimpleController {
    
        @GetMapping("/hello")
        public String hello(){
            return "hello";
        }
    
        @GetMapping("/my")
        public String my(){
            return "my";
        }
    }

    @Component
    public class Security extends WebSecurityConfigurerAdapter {
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    .antMatchers("/", "/hello").permitAll()
                    .anyRequest().authenticated()
                    .and()
                    .formLogin()
                    .and()
                    .httpBasic();
        }
    }

- WebSecurityConfigurerAdapter를 상속받아 configure 메서드를 오버라이딩함으로써 시큐리티 설정을 할 수 있습니다.
- index.html, hello.html 파일에 접근할 때( / , /hello )를 제외하고 모든 사용자 요청은 인증을 받도록 설정하였습니다.
- httpBasic 그리고 formLogin 둘 동시에 인증을 받도록 설정하였습니다.

### 결과화면

---

- http://localhost:8080/my 로 접근할 시 다음과 같이 formLogin 화면이 출력됩니다. ( / 와 /hello 경로로 접근 시 바로 접근할 수 있습니다)
- 로그인에 필요한 정보는 기본적으로 username: user, password는 아래처럼 스프링 부트가 실행될 때 콘솔창에 출력되는 비밀번호를 입력해야합니다.

## DB 로그인

---

거의 모든 웹에서는 DB를 통해 유저정보를 관리하고 유저가 로그인같은 인증 절차를 받으려고 시도할 때 DB에 있는 정보를 토대로 인증 절차를 진행하게 됩니다. 아래는 스프링 부트를 통해 어떻게 인증 절차를 구현하는 지 알아보는 프로젝트입니다.

### 의존성관리

---

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- 아래는 기존 것에서 추가 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
    
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
        </dependency>
    </dependencies>

### 소스코드

---

    @Entity
    public class Account {
    
        @Id
        @GeneratedValue
        private Long id;
    
        private String userName;
    
        private String password;
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getUsername() {
            return userName;
        }
    
        public void setUsername(String username) {
            this.userName = username;
        }
    
        public String getPassword() {
            return password;
        }
    
        public void setPassword(String password) {
            this.password = password;
        }
    
        @Override
        public String toString() {
            return "Account{" +
                    "id=" + id +
                    ", username='" + userName + '\'' +
                    ", password='" + password + '\'' +
                    '}';
        }
    }

DB와 어플리케이션 간의 데이터 이동이 있을 때 그 데이터에 대한 정보를 담고 있는 객체의 클래스입니다. ( Data Transfer Object(DTO) 라 부름 )

    public interface AccountRepository extends JpaRepository<Account, Long> {
        Optional<Account> findByUserName(String username);
    }

- JpaRepository 를 상속하여 DB에 의해 관리되는 정형화된 데이터를 추상화된 형태로 접근할 수 있습니다.
- findByUserName 메서드를 통해 username을 기준으로 데이터를 가져올 수 있습니다.

    @Component
    public class AccountAddRunner implements ApplicationRunner {
    
        @Autowired
        AccountService accountService;
    
        @Override
        public void run(ApplicationArguments args) throws Exception {
    
            Account saelobi = accountService.createAccount("saelobi", "1234");
            System.out.println(saelobi.getUsername() + " " + saelobi.getPassword());
        }
    }

H2 데이터베이스에 사용자 정보를 임의로 넣는 코드입니다.

    @Service
    public class AccountService implements UserDetailsService {
    
        @Autowired
        private AccountRepository accountRepository;
    
        @Autowired
        private PasswordEncoder passwordEncoder;
    
        public Account createAccount(String username, String password) {
            Account account = new Account();
            account.setUsername(username);
            account.setPassword(passwordEncoder.encode(password));
            return accountRepository.save(account);
        }
    
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<Account> byUserName = accountRepository.findByUserName(username);
            Account account = byUserName.orElseThrow(() -> new UsernameNotFoundException(username));
            return new User(account.getUsername(), account.getPassword(), authorities());
        }
    
        private Collection<? extends GrantedAuthority> authorities() {
            return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));
        }
    }

- Service 계층에 계정을 만드는 메서드(createAccount)와 UserDetailsService의 인터페이스를 구현한 loadUserByUserName이 있습니다.
- UserDetailsService의 loadUserByUsername은 사용자 인증 처리를 할 시,사용자가 보내온 인증 정보와 DB에 적재된 사용자 로그인 데이터의 일치 여부를 확인하는 중요한 역할을 하는 메서드입니다.

    @Component
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    .antMatchers("/", "/hello").permitAll()
                    .anyRequest().authenticated()
                    .and()
                    .formLogin()
                    .and()
                    .httpBasic();
        }
    
        @Bean
        public PasswordEncoder passwordEncoder() {
            return PasswordEncoderFactories.createDelegatingPasswordEncoder();
        }
    }

- 스프링 부트 시큐리티 설정 클래스에 PasswordEncoder 에 대한 반환값을 생성하는 메서드를 작성하였습니다.
- PasswordEncoder를 반환하는 메서드를 구현하지 않으면 스프링 부트에서는 PassEncoder에 대한 정보를 찾을 수 없다면서 예외를 발생시킵니다.
- 따라서 스프링 부트에서 권장하는 사항을 그대로 소스에 반영하는 것이 좋습니다.

## OAuth2 로그인

---

OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때 인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.

### OAuth2 in-memory 방식으로 간단한 구현

---

OAuth는 인증서버와 자원 서버를 하나의 애플리케이션에서 구현할 수도 있고, 분리할 수도 있다. 여기에서는 두 개를 하나의 애플리케이션에서 구현할 것이다. Resource Owner, Client 관리는 in-memory를 이용할 것이다. 아래와 같이 application.yml에 Resource Owner를 지정하고, Client를 쉽게 등록할 수 있다.

    security:
      user:
        name: user
        password: test
      oauth2:
        client:
          client-id: foo
          client-secret: bar

그다음은 Resource Server, Authorization Server의 설정을 구현할 것이다. @EnableResourceServer, @EnableAuthorizationServer 두개의 어노테이션으로 쉽게 인증서버와 자원서버를 구성할 수 있다.

    @EnableResourceServer  // API 서버 인증(또는 권한 설정)
    @EnableAuthorizationServer // 자원서버 설정
    @Configuration
    public class ResourceServerConfigurerAdapterImpl extends ResourceServerConfigurerAdapter {
    
        @Override
        public void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    .antMatchers("/users").access("#oauth2.hasScope('read')");
        }
    
    }

위와 같이 지정을 하게 되면 /users라는 자원에 접근하기 위해서는 access_token이 있어야 접근을 할 수 있다. 자원에 대한 CRUD는 Rest Repositories(Spring Data Rest를 스프링 부트에 맞도록 쉽게 사용할 수 있는 형태 제공하는 부분이면 Rest API 서버를 쉽게 만들어 준다)를 이용할 것이다. 도메인 구성등에 대한 정보는 소스을 참조 할 수 있다. 이제 실제로 /users를 접근을 할 수 없는지 테스트를 해보자. 테스트는 아래와 같이 junit을 사용할 것이다.

    @Test
    public void when_callApi_expect_unauthorized() throws Exception {
        mockMvc.perform(get("/users")).andExpect(status().isOk());
    }

그렇다. response 결과는 401이 넘어와 실패했다. access_token없이 접근해서 그렇다. 당연한 결과이다. 위 소스는 isOk에서 isUnauthorized로 수정해주면될 것 같다. 그러면 테스트 결과는 성공일 것이다. 그다음은 토큰을 생성한후 API를 호출해 성공하는 테스트를 작성할 것 이다. 먼저 rest로 토큰을 얻어보자. 이 /oauth/token는 Spring OAuth에서 지정해준 URI이다. 이 URI는 Basic Auth를 사용하여 ClientID와 Secret을 포함하고 바디값으로 grant_type, client_id, username, password, scope를 넘기면 토큰 값을 얻을 수 있다.

    private String obtainAccessToken(String username, String password) throws Exception {
    
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "password");
        params.add("client_id", CLIENT_ID); //foo
        params.add("username", username);
        params.add("password", password);
        params.add("scope", SCOPE); //read
    
        ResultActions result
                = mockMvc.perform(post("/oauth/token")
                .params(params)
                .with(httpBasic(CLIENT_ID, CLIENT_SECRET)) //foo, bar
                .accept(CONTENT_TYPE)) //"application/json;charset=UTF-8"
                .andExpect(status().isOk())
                .andExpect(content().contentType(CONTENT_TYPE));//"application/json;charset=UTF-8"
    
        String resultString = result.andReturn().getResponse().getContentAsString();
    
        JacksonJsonParser jsonParser = new JacksonJsonParser();
        return jsonParser.parseMap(resultString).get("access_token").toString();
    }

위와같이 넘기면 access_token값을 얻을 수 있다.

    @Test
    public void when_callUsers_expect_success() throws Exception {
        String accessToken =obtainAccessToken(SECURITY_USERNAME,SECURITY_PASSWORD);
        mockMvc.perform(get("/users")
                .header("Authorization", "Bearer " + accessToken)
                .accept(CONTENT_TYPE))//"application/json;charset=UTF-8"
                .andExpect(status().isOk())
                .andExpect(content().contentType(CONTENT_TYPE));//"application/json;charset=UTF-8"
    }

그다음 생성한 토큰을 이용해서 header 값에 access_token을 넣은 후 호출하면 호출에 성공한 모습을 확인할 수 있다. 이것의 전체적인 구현인 토큰 관리, client, user 등록등 In-memory기반에 의하여 구현되었다. 그렇기 때문에 서버가 종료되면 기존에 발급되었던 토큰들이 모두 소멸된다. Product로 사용하기 위해서는 JdbcTokenStore빈을 통해서 토큰 관리, client, user 등록등을 영속화하여 사용해야 한다. in-memory 방식으로 구현한 OAuth소스는 이곳에서 확인할 수 있다.

### OAuth2 JdbcTokenStore등을 이용한 데이터 영속화

---

이제 Authorization Server, Resource Server을 커스터마이징하여 데이터들의 관리를 영속화할 것이다. 가장먼저 해야할것은 Spring Security Oauth에 맞는 디비에 대한 스키마 를 만드는것이다. 그 후 TokenStore의 빈을 등록하는것이다. TokenStore 빈을 등록을하게 되면 Token관리, Client관리등을 디비로 할 수 있게된다.

    @Bean
    public TokenStore JdbcTokenStore(@Qualifier("dataSource") DataSource dataSource) {
        return new JdbcTokenStore(dataSource);
    }

그 다음 Authorization Server, Resource Server를 두개의 클래스로 분리할 것이다. ResourceServerConfigurerAdapter, AuthorizationServerConfigurerAdapter를 상속해서 세부내용을 구현해야 한다. 그래야 좀 더 세부적으로 Authorization Server, Resource Server 컨트롤 가능하다. 아래는 각각의 구현체 구조이다.

    @Configuration
    @EnableResourceServer
    public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {
    
            @Override
          public void configure(ResourceServerSecurityConfigurer resources) {
    
          }
          @Override
          public void configure(HttpSecurity http) throws Exception {
              // 자원서버 접근권한 설정
          }
    
    }

    @Configuration
    @EnableAuthorizationServer
    public class DemoApplication extends AuthorizationServerConfigurerAdapter {
    // ...
       @Override
       public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
    // OAuth2 인증서버 자체의  보안 정보를 설정하는 부분
       }
       @Override
       public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
    // Client 에 대한 정보를  설정하는 부분
       }
       @Override
       public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    // OAuth2 서버가 작동하기 위한 Endpoint에 대한 정보를 설정
       }
       // ...
    }

Authorization Server, Resource Server를 분리하게 되면 yml에 등록한 클라이언트는 의미가없어진다. 이유는 AuthorizationServerConfigurerAdapter 클래스를 상속함으로써 오버라이딩이되어 authorizationServer에 대한 정의를 여기에 할것이기 때문이다. 그리고 만약 세부구현체를 구현을안하고 accessToken을 생성하려고하면 clientDetailsService를 정의하라는 에러를 만날것이다. 먼저 테스트를 위해 인메모리 등록을 할 것이다. 만약 inMemory가 아닌 외부 db를 사용하고싶으면 아래의 소스 부분에 inMemory부분을 jdbc 방식으로 바꾸면 된다.

    @EnableResourceServer  // API 서버 인증, 권한 설정
    @Configuration
    public class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{
    
        @Override
        public void configure(ClientDetailsServiceConfigurer clients)
                throws Exception {
            clients.inMemory() // 이부분을 jdbc를 쓰면 데이터베이스값을 이용할 수 있다.
                    .withClient("foo")
                    .secret("bar")
                    .authorizedGrantTypes(
                            "password","authorization_code", "refresh_token")
                    .scopes("read");
        }
    
    }

그런데 이렇게 클라이언트 정보를 정의하고 accessToken을 생성하려고 하면 "Unsupported grant type: password"라는 메시지를 만난다. 이 메시지를 해결하기 위해서는 AuthorizationServer에 AuthenticationManager를 제공해야한다. 그래서 아래와같이 소스를 추가해줘야한다.

    public class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{
    
        @Autowired
        private AuthenticationManager authenticationManager;
    
        @Autowired
        private TokenStore JdbcTokenStore;
    
        @Override
        public void configure(ClientDetailsServiceConfigurer clients)
                throws Exception {
            clients.inMemory()
                    .withClient("foo")
                    .secret("bar")
                    .authorizedGrantTypes(
                            "password","authorization_code", "refresh_token")
                    .scopes("read");
        }
    
        @Override
        public void configure(
                AuthorizationServerEndpointsConfigurer endpoints)
                throws Exception {
    
            endpoints
                    .tokenStore(JdbcTokenStore)
                    .authenticationManager(authenticationManager);
        }
    
    }

위와 같이 추가되면 이제 토큰은 inMemory가 아닌 DB에 저장이 된다. 그리고 "Unsupported grant type: password"에대한 에러도 사라지고 AccessToken이 생성 될것이다. 만약 클라이언트 관리도 디비에서 하려면 아래와 같이 변경해주면 된다.

    @Override
    public void configure(ClientDetailsServiceConfigurer clients)
            throws Exception {
        clients.jdbc(dataSource);
    }

그다음 oauth_client_details 테이블의 아래와같이 클라이언트 정보를 추가해줘야 한다.

    INSERT INTO PUBLIC.OAUTH_CLIENT_DETAILS (CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, SCOPE, AUTHORIZED_GRANT_TYPES, WEB_SERVER_REDIRECT_URI, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, ADDITIONAL_INFORMATION, AUTOAPPROVE) VALUES ('foo', '', 'bar', 'read', 'password,authorization_code,refresh_token', '', '', null, null, '{}', '');

그리고 위와 같이 Client에 관한 데이터를 Insert해주면 된다. 그렇게 되면 DB에서 클라이언 정보를 관리할 수 있게 된다.

### Authorization Server, Resource Server 애플리케이션 분리

---

지금은 하나의 어플리케이션에 Authorization Server, Resource Server를 구현했다. 만약 다른 어플리케이션에 다른 데이터베이스를 바라보고 Authorization Server, Resource Server를 구성했다면 HTTP 통신을 통해 토큰을 확인해야한다. 그럴려면 먼저 인증서버에서 accessToken이 유효한지 확인할 수 있는 URL이 있어야 한다. 하지만 이것은 스프링에서 아래와 같이 설정해준다면 기본적으로 기능을 제공해준다.

    @Override
    public void configure(
      AuthorizationServerSecurityConfigurer oauthServer)
      throws Exception {
        oauthServer
          .tokenKeyAccess("permitAll()")
          .checkTokenAccess("isAuthenticated()");
          // Token 정보를 API(/oauth/check_token)를 활성화 시킨다. ( 기본은 denyAll )
    }

그리고 자원 서버에서도 다른 클라이언트가 접근한다면 token이 유효한지 인증서버를 통해 체크를 해줘야 한다. 이 설정 또한 쉽게 아래와 같이 URL만 등록해주면 된다. 아래는 YML, 빈을 통해 등록하는 방식을 나열했다.

    # OAuth2 서버에서 기본적으로 Token정보를 받아오는 URL
    security.resource.token-info-uri: http://localhost:8080/oauth/check_token

    @Primary
    @Bean
    public RemoteTokenServices tokenService() {
        RemoteTokenServices tokenService = new RemoteTokenServices();
        tokenService.setCheckTokenEndpointUrl(
          "http://localhost:8080/spring-security-oauth-server/oauth/check_token");
        tokenService.setClientId("foo");
        tokenService.setClientSecret("bar");
        return tokenService;
    }

위와 같이 등록하면 자원서버는 등록된 URL로 accessToken이 유효한지 체크를 할것이다.

[Wan Blog](https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/)

[Wan Blog](https://minwan1.github.io/2018/02/24/2018-03-11-Spring-OAuth구현/)

## OAuth2 소셜 로그인

---

[Spring Security OAuth2 소셜 인증 | Popit](https://www.popit.kr/spring-security-oauth2-%EC%86%8C%EC%85%9C-%EC%9D%B8%EC%A6%9D/)

Spring Scurity OAuth2를 활용해서 Facebook, Google 계정 기반으로 정말 간단하게 인증 처리를 할 수 있습니다. 들어가기에 앞서 [OAuth 2인증 방식 : Authorization Code Grant](https://github.com/minwan1/spring-security-oauth2-example/blob/master/docs/step-1:oauth1,oauth2%EB%9E%80.md#%EC%9D%B8%EC%A6%9D-%EC%A2%85%EB%A5%98) **반드시 기본적인 이해를 하시는것을 권장드립니다.** [생활코딩](https://www.youtube.com/watch?v=hm2r6LtUbk8&index=1&list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-)에도 잘 정의되어있습니다.

Google, Facebook App 생성 및 Https 설정을 하지 않았다면 [step-00: gogole, facebook, https 설정](https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/doc/step-00.md)을 참고하여 작업을 완료해주세요. **전체코드는 [Github](https://github.com/cheese10yun/spring-security-oauth2-social)에 공게되어 있습니다**.

### maven

---

    <dependency>
        <groupId>org.springframework.security.oauth</groupId>
        <artifactId>spring-security-oauth2</artifactId>
        <version>2.3.3.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.security.oauth.boot</groupId>
        <artifactId>spring-security-oauth2-autoconfigure</artifactId>
        <version>2.0.0.RELEASE</version>
    </dependency>

### application.yml

---

    facebook:
      client:
        clientId: <your-client-id>
        clientSecret: <your-secret>
        accessTokenUri: https://graph.facebook.com/oauth/access_token
        userAuthorizationUri: https://www.facebook.com/dialog/oauth
        tokenName: oauth_token
        authenticationScheme: query
        clientAuthenticationScheme: form
      resource:
        userInfoUri: https://graph.facebook.com/me
    google :
      client :
        clientId : <your-client>
        clientSecret: <your-secret>
        accessTokenUri: https://www.googleapis.com/oauth2/v4/token
        userAuthorizationUri: https://accounts.google.com/o/oauth2/v2/auth
        clientAuthenticationScheme: form
        scope:
        - email
        - profile
      resource:
        userInfoUri: https://www.googleapis.com/oauth2/v3/userinfo

### 소셜인증구현

---

    class ClientResources {
        @NestedConfigurationProperty
        private AuthorizationCodeResourceDetails client = new AuthorizationCodeResourceDetails();
        @NestedConfigurationProperty
        private ResourceServerProperties resource = new ResourceServerProperties();
        public AuthorizationCodeResourceDetails getClient() {
            return client;
        }
        public ResourceServerProperties getResource() {
            return resource;
        }
    }

ClientResources 클래스를 생성합니다. 해당 클래스는 위에서 설정한 property 설정을 편리하게 사용할 수 있습니다.

    EnableWebSecurity
    @EnableOAuth2Client
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      ....
      @Bean
        @ConfigurationProperties("facebook")
        public ClientResources facebook() {
            return new ClientResources();
        }
        @Bean
        @ConfigurationProperties("google")
        public ClientResources google() {
            return new ClientResources();
        }
    }

EnableWebSecurity, EnableOAuth2Client 어노테이션을 추가합니다.

위에서 작성한 properties 들을 빈으로 등록해줍니다. ClientResources 클래스 덕분에 저렇게 쉽게 property 설정을 쉽게 설정할 수 있습니다.

    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      ...
      @Override
        protected void configure(HttpSecurity http) throws Exception {
            // @formatter:off
    		http.antMatcher("/**").authorizeRequests().antMatchers("/", "/login**").permitAll().anyRequest()
    				.authenticated().and().exceptionHandling()
    				.authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/")).and()
    				.addFilterBefore(ssoFilter(), BasicAuthenticationFilter.class);
    		// logout
    		http.logout()
                    .invalidateHttpSession(true)
                    .clearAuthentication(true)
                    .logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
                        .logoutSuccessUrl("/")
                    .permitAll();
    		// @formatter:on
        }
    }

스프링 시큐리티 코드입니다. 해당 설정은 어렵지 않으니 자세한 설명은 생략하겠습니다. 중요한 포인트는 addFilterBefore메서드로 ssoFilter 필터를 등록했습니다. 해당 필터는 아래에서 다루겠습니다.

    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      ...
      @Bean
          public FilterRegistrationBean oauth2ClientFilterRegistration(OAuth2ClientContextFilter filter) {
              FilterRegistrationBean registration = new FilterRegistrationBean();
              registration.setFilter(filter);
              registration.setOrder(-100);
              return registration;
          }
    }

인증 요청에 따른 리다이렉션을 위한 빈을 등록합니다. 이때 setOrder 메서드로 Spring Security 필터 보다 우선순위를 낮게 설정합니다.

    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      ...
      private Filter ssoFilter() {
            CompositeFilter filter = new CompositeFilter();
            List<Filter> filters = new ArrayList<>();
            filters.add(ssoFilter(google(), "/login/google")); //  이전에 등록했던 OAuth 리다이렉트 URL 
            filters.add(ssoFilter(facebook(), "/login/facebook"));
            filter.setFilters(filters);
            return filter;
        }
        private Filter ssoFilter(ClientResources client, String path) {
            OAuth2ClientAuthenticationProcessingFilter filter = new OAuth2ClientAuthenticationProcessingFilter(path);
            OAuth2RestTemplate restTemplate = new OAuth2RestTemplate(client.getClient(), oauth2ClientContext);
            filter.setRestTemplate(restTemplate);
            UserInfoTokenServices tokenServices = new UserInfoTokenServices(client.getResource().getUserInfoUri(), client.getClient().getClientId());
            tokenServices.setRestTemplate(restTemplate);
            filter.setTokenServices(tokenServices);
            return filter;
        }
    }

위에서 configure 등록했던 ssoFilter 설정 입니다. 위에서 등록했던 빈 google(), 이전에 등록했던 OAuth 리다이렉트 URL `/login/google 기반으로 Filter를 생성합니다.`

**OAuth2ClientAuthenticationProcessingFilter 필터는 인증 서버에서 OAuth2 액세스 토큰을 획득하고 인증 객체를 SecurityContext에로드하는 데 사용할 수 있는 OAuth2 클라이언트 필터입니다.**

setRestTemplate 메스들을 통해서 OAuth2 인증 REST 요청을 만들 수 있는 RestTemplate 객체를 지정합니다.

    RestController
    public class Controller {
        @RequestMapping(value = "/", method = RequestMethod.GET)
        public Principal home(Principal principal) {
            return principal;
        }
    }

소셜 인증 이후 해당 컨트롤러로 이동하면 OAuth2ClientAuthenticationProcessingFilter 필터가 등록한 SecurityContextHolder 정보를 확인할 수 있습니다.

## 사용자 역할과 권한

---

- `역할(Role)`은 사용자에게 부여된 역할을, `권한(Permission = Authority)`은 사용자의 역할에 부여된 권한을 의미한다. 개념적으로 1개의 역할은 복수개의 권한을 가질 수 있다. (즉, 1:N의 관계이다.)
- **Spring Security**는 역할과 권한을 구조적으로 분리하지 않고, **UserDetails#getAuthorities()**로 획득 가능한 **GrantedAuthority** 인터페이스 구현체의 목록으로 설계하였다. 다만, 역할의 경우 문자열 앞에 `ROLE_`을 붙이도록 하여, 권한과 구분되도록 설계하였다. 개발자는 실제 구현시 역할과 권한을 별도의 저장소로 분리하여 1:N의 관계로 설계하고, **UserDetails** 구현체 작성시에는 해당 사용자에게 부여된 역할과 권한을 모두 문자열로 **UserDetails#getAuthorities()**을 통해 획득되도록 구현하면 된다. [[관련 링크1]](https://stackoverflow.com/a/19542316) [[관련 링크2]](https://stackoverflow.com/a/9029859)
- 역할은 스프링 빈의 메써드 레벨에서 **@PreAuthorize(“hasRole(‘ADMIN’)”)**와 같이 특정 역할을 부여 받았는지 검사할 수 있다. 물리적으로는 **ROLE_ADMIN**이라는 문자열을 검사하게 된다.
- 권한은 스프링 빈의 메써드 레벨에서 **@PreAuthorize(“hasAuthority(‘RESET_USER_PASSWORD’)”)**와 같이 특정 권한을 부여 받았는지 검사할 수 있다. 물리적으로는 **RESET_USER_PASSWORD**라는 문자열을 검사하게 된다.

### 종속성 추가

---

Spring Boot 기반 프로젝트는 /build.gradle 파일에 아래 내용을 추가하면 Spring Security 사용 준비가 완료된다.

    dependencies {
        implementation("org.springframework.boot:spring-boot-starter-security")
    }

### 소스코드 - 정적 권한 설정

---

    package com.jsonobject.example.demo
    
    import org.springframework.context.annotation.Configuration
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
    
    @Configuration
    @EnableWebSecurity
    @EnableGlobalMethodSecurity(prePostEnabled = true)
    class SecurityConfig : WebSecurityConfigurerAdapter() {
    
        fun configGlobal(auth: AuthenticationManagerBuilder) {
    
            // 테스트 용도의 인메모리에 저장되는 사용자 계정과 역할, 권한 정보를 생성한다.
            // 프로덕션 레벨에서는 물리 저장소에 CRUD를 수행하는 UserDetails, UserDetailsService 구현체를 작성해야 한다.
            auth.inMemoryAuthentication().withUser("user").password("password").roles("ADMIN").authorities("GET_USER_INFO")
        }
    }

### @PreAuthorize, 역할과 권한 인증

- **Spring Security** 생태계에서는 `@PreAuthorize`를 이용하여 스프링 빈의 메써드 레벨에서 역할과 권한을 제어할 수 있다. 그렇다면 실제 지정된 역할과 권한을 충족하지 않는 사용자의 접근 시도시 오류 제어는 어떻게 해야 할까? 오류 발생시 **org.springframework.security.access.AccessDeniedException** 예외를 발생시키는데, **Spring Security**에서의 오류 제어는 사용자 인증 오류(**403 FORBIDDEN**)의 경우 `AccessDeniedHandler` 구현체를 작성하면 되고, 역할과 권한 인증 오류(**401 UNAUTHORIZED**)의 경우 `AuthenticationEntryPoint` 구현체를 작성하면 된다. [[관련 링크]](https://stackoverflow.com/a/53607022)

[02. 스프링 시큐리티(spring-security)02 - DB와 연동(유저, 유저권한)](https://ryudung.tistory.com/20)

### 소스코드 - 동적 권한 설정

    package com.example.security;
    import javax.sql.DataSource;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.context.annotation.Bean;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      
      @Autowired
      private DataSource dataSource;
      
      @Override
      protected void configure(HttpSecurity http) throws Exception {
        // (생략)
        
      }
      
      @Override
      protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.jdbcAuthentication()
        .dataSource(dataSource)
        .rolePrefix("ROLE_")
        .usersByUsernameQuery("select username, replace(password, '$2y', '$2a'), true from users where username = ?")
        .authoritiesByUsernameQuery("select username, role from simple_users where username = ?"); 
      } 
      // (생략)
    }

[Spring Boot: 시큐리티(Security) - 3 - 로그인 및 권한 정보를 DB에서 가져오기 - BGSMM](http://yoonbumtae.com/?p=1202)

## 커스텀 로그인 페이지 만들기

---

    package com.example.security;
    import org.springframework.context.annotation.Bean;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
      
      @Override
      protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
        .antMatchers("/adminOnly").hasAuthority("ROLE_ADMIN")
        .antMatchers("/**").permitAll()  // 넓은 범위의 URL을 아래에 배치한다.
        .anyRequest().authenticated()
        .and()
        .formLogin().loginPage("/login").failureUrl("/login?error").permitAll() 
        .defaultSuccessUrl("/")  
        .and()
        .logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
        .addLogoutHandler(new TaskImplementingLogoutHandler()).permitAll().logoutSuccessUrl("/");  
        // 로그아웃 기본 url은 (/logout)
        // 새로 설정하려면 .logoutUrl("url") 사용  
        
      }
      
      @Override
      protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
        .withUser("admin").password(passwordEncoder().encode("1234")).roles("ADMIN")
        .and()
        .withUser("guest").password(passwordEncoder().encode("guest")).roles("GUEST");
      }
      
      // passwordEncoder() 추가
      @Bean
      public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
      }
    }

    package com.example.security;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.web.authentication.logout.LogoutHandler;
    public class TaskImplementingLogoutHandler implements LogoutHandler {
      
        Logger logger = LoggerFactory.getLogger(TaskImplementingLogoutHandler.class);
        @Override
        public void logout(HttpServletRequest req, HttpServletResponse res,
                Authentication authentication) {
          
          logger.info("로그아웃 되었습니다.");
        }
    }

    @RequestMapping("/login")
    public String loginForm() {
      return "login-form";
    }

    <html xmlns:th="https://www.thymeleaf.org">
      <head >
        <title>Please Login</title>
      </head>
      <body>
        <div th:fragment="content">
            <form name="f" th:action="@{/login}" method="post">               
                <fieldset>
                    <legend>Please Login</legend>
                    <div th:if="${param.error}" class="alert alert-error">    
                        Invalid username and password.
                    </div>
                    <div th:if="${param.logout}" class="alert alert-success"> 
                        You have been logged out.
                    </div>
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username"/>        
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password"/>    
                    <div class="form-actions">
                        <button type="submit" class="btn">Log in</button>
                    </div>
                </fieldset>
            </form>
        </div>
      </body>
    </html>

src/main/resources/templates/login-form.html

[Spring Boot: 시큐리티(Security) - 2 - 커스텀 로그인 페이지 만들기 - BGSMM](http://yoonbumtae.com/?p=1184)

# Next...

자동로그인은 어떻게 할까?